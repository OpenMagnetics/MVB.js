<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenMagnetics Virtual Builder - Browser Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #00d9ff; margin-bottom: 10px; }
    .container { max-width: 1200px; margin: 0 auto; }
    .controls {
      background: #16213e;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .controls label { display: block; margin-bottom: 5px; color: #aaa; }
    .controls select, .controls input, .controls button {
      padding: 8px 12px;
      margin-right: 10px;
      margin-bottom: 10px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #0f3460;
      color: #fff;
    }
    .controls button {
      background: #00d9ff;
      color: #000;
      cursor: pointer;
      font-weight: bold;
    }
    .controls button:hover { background: #00b8d9; }
    .controls button:disabled { background: #555; cursor: not-allowed; }
    #viewer {
      width: 100%;
      height: 500px;
      background: #0f0f1a;
      border-radius: 8px;
      border: 1px solid #333;
    }
    #status {
      padding: 10px;
      background: #16213e;
      border-radius: 4px;
      margin-top: 10px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    .success { color: #00ff88; }
    .error { color: #ff4444; }
    .info { color: #00d9ff; }
    #downloadLinks { margin-top: 10px; }
    #downloadLinks a {
      color: #00d9ff;
      margin-right: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ§² OpenMagnetics Virtual Builder</h1>
    <p>Browser-based 3D magnetic component geometry using OpenCASCADE.js</p>

    <div class="controls">
      <label>Test Case:</label>
      <select id="testCase">
        <option value="toroidal_single">Toroidal - Single Turn</option>
        <option value="toroidal_full_layer">Toroidal - Full Layer</option>
        <option value="concentric_single">Concentric - Single Turn</option>
        <option value="concentric_multilayer">Concentric - Multi-layer</option>
        <option value="rectangular_wire">Rectangular Wire Turn</option>
      </select>

      <label>Wire Type:</label>
      <select id="wireType">
        <option value="round">Round</option>
        <option value="rectangular">Rectangular</option>
      </select>

      <label>Wire Diameter (mm):</label>
      <input type="number" id="wireDiameter" value="0.5" min="0.1" max="5" step="0.1">

      <br><br>
      <button id="generateBtn" onclick="generateGeometry()">Generate Geometry</button>
      <button id="exportStlBtn" onclick="exportSTL()" disabled>Export STL</button>
      <button id="exportStepBtn" onclick="exportSTEP()" disabled>Export STEP</button>

      <div id="downloadLinks"></div>
    </div>

    <div id="viewer">
      <canvas id="canvas"></canvas>
    </div>

    <div id="status" class="info">Loading OpenCASCADE.js... This may take a few seconds.</div>
  </div>

  <!-- Three.js for visualization -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Replicad -->
  <script type="module">
    import opencascade from 'https://unpkg.com/replicad-opencascadejs@0.19.0/dist/replicad-opencascadejs.js';
    import { setOC } from 'https://unpkg.com/replicad@0.19.0/dist/replicad.js';
    import * as replicad from 'https://unpkg.com/replicad@0.19.0/dist/replicad.js';

    // Make replicad globally available
    window.replicad = replicad;
    window.currentShape = null;

    // Test data generators
    const testCases = {
      toroidal_single: () => ({
        turnDescription: {
          coordinates: [-0.008, 0],
          rotation: 0,
          dimensions: null,
          additionalCoordinates: [[-0.015, 0]]
        },
        wireDescription: {
          wireType: document.getElementById('wireType').value,
          outerDiameter: parseFloat(document.getElementById('wireDiameter').value) / 1000
        },
        bobbinDescription: {
          columnDepth: 0.005,
          columnWidth: 0.01,
          columnShape: 'round',
          windingWindowRadialHeight: 0.007
        },
        isToroidal: true
      }),

      toroidal_full_layer: () => {
        const numTurns = 12;
        const turns = [];
        for (let i = 0; i < numTurns; i++) {
          const angle = (i / numTurns) * 360;
          const radial = 0.008;
          const x = -radial * Math.cos(angle * Math.PI / 180);
          const z = radial * Math.sin(angle * Math.PI / 180);
          turns.push({
            coordinates: [x, z],
            rotation: angle,
            additionalCoordinates: [[x * 1.8, z * 1.8]]
          });
        }
        return {
          turns,
          wireDescription: {
            wireType: document.getElementById('wireType').value,
            outerDiameter: parseFloat(document.getElementById('wireDiameter').value) / 1000
          },
          bobbinDescription: {
            columnDepth: 0.005,
            columnWidth: 0.01,
            columnShape: 'round',
            windingWindowRadialHeight: 0.007
          },
          isToroidal: true
        };
      },

      concentric_single: () => ({
        turnDescription: {
          coordinates: [0.005, 0],
          dimensions: null
        },
        wireDescription: {
          wireType: document.getElementById('wireType').value,
          outerDiameter: parseFloat(document.getElementById('wireDiameter').value) / 1000
        },
        bobbinDescription: {
          columnDepth: 0.004,
          columnWidth: 0.003,
          columnShape: 'rectangular',
          windingWindowHeight: 0.01,
          windingWindowWidth: 0.005
        },
        isToroidal: false
      }),

      concentric_multilayer: () => {
        const turns = [];
        for (let layer = 0; layer < 3; layer++) {
          for (let i = 0; i < 5; i++) {
            turns.push({
              coordinates: [0.004 + layer * 0.0006, -0.003 + i * 0.0012],
              dimensions: null
            });
          }
        }
        return {
          turns,
          wireDescription: {
            wireType: 'round',
            outerDiameter: 0.0005
          },
          bobbinDescription: {
            columnDepth: 0.003,
            columnWidth: 0.003,
            columnShape: 'rectangular'
          },
          isToroidal: false
        };
      },

      rectangular_wire: () => ({
        turnDescription: {
          coordinates: [0.006, 0],
          dimensions: [0.002, 0.0005] // width, height in meters
        },
        wireDescription: {
          wireType: 'rectangular',
          outerWidth: 0.002,
          outerHeight: 0.0005
        },
        bobbinDescription: {
          columnDepth: 0.004,
          columnWidth: 0.004,
          columnShape: 'round',
          windingWindowHeight: 0.01
        },
        isToroidal: false
      })
    };

    // Initialize OpenCASCADE
    async function init() {
      try {
        log('Initializing OpenCASCADE.js...', 'info');
        const oc = await opencascade();
        setOC(oc);
        window.oc = oc;
        log('âœ“ OpenCASCADE.js initialized successfully!', 'success');
        
        // Initialize Three.js viewer
        initViewer();
        
        document.getElementById('generateBtn').disabled = false;
      } catch (error) {
        log('âœ— Failed to initialize: ' + error.message, 'error');
        console.error(error);
      }
    }

    // Three.js viewer
    let scene, camera, renderer, controls;
    
    function initViewer() {
      const container = document.getElementById('viewer');
      const canvas = document.getElementById('canvas');
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f0f1a);
      
      camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.001, 1000);
      camera.position.set(0.05, 0.05, 0.05);
      
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      
      // Grid helper
      const gridHelper = new THREE.GridHelper(0.1, 20, 0x333333, 0x222222);
      scene.add(gridHelper);
      
      // Axes helper
      const axesHelper = new THREE.AxesHelper(0.02);
      scene.add(axesHelper);
      
      animate();
    }
    
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    
    function addMeshToScene(meshData) {
      // Remove old mesh
      const oldMesh = scene.getObjectByName('magneticPart');
      if (oldMesh) scene.remove(oldMesh);
      
      // Create geometry from mesh data
      const geometry = new THREE.BufferGeometry();
      
      const vertices = new Float32Array(meshData.vertices.flat());
      const normals = new Float32Array(meshData.normals.flat());
      const indices = new Uint32Array(meshData.faces.flat());
      
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      
      const material = new THREE.MeshPhongMaterial({
        color: 0x00d9ff,
        shininess: 100,
        side: THREE.DoubleSide
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.name = 'magneticPart';
      scene.add(mesh);
      
      // Center camera on mesh
      geometry.computeBoundingSphere();
      const center = geometry.boundingSphere.center;
      const radius = geometry.boundingSphere.radius;
      camera.position.set(center.x + radius * 2, center.y + radius * 2, center.z + radius * 2);
      controls.target.copy(center);
    }

    // Generate geometry
    window.generateGeometry = async function() {
      const testCase = document.getElementById('testCase').value;
      const testData = testCases[testCase]();
      
      log('Generating geometry: ' + testCase, 'info');
      
      try {
        const { ReplicadBuilder } = await import('./src/replicadBuilder.js');
        const { WireDescription, TurnDescription, BobbinProcessedDescription, WireType } = await import('./src/types.js');
        
        const builder = new ReplicadBuilder(replicad);
        
        // Handle multi-turn cases
        if (testData.turns) {
          const shapes = [];
          for (const turn of testData.turns) {
            const turnDesc = new TurnDescription(turn);
            const wireDesc = new WireDescription({
              wireType: testData.wireDescription.wireType === 'rectangular' ? WireType.RECTANGULAR : WireType.ROUND,
              outerDiameter: testData.wireDescription.outerDiameter
            });
            const bobbinDesc = new BobbinProcessedDescription(testData.bobbinDescription);
            
            const shape = builder.getTurn(turnDesc, wireDesc, bobbinDesc, testData.isToroidal);
            shapes.push(shape);
          }
          window.currentShape = replicad.makeCompound(shapes);
        } else {
          const turnDesc = new TurnDescription(testData.turnDescription);
          const wireDesc = new WireDescription({
            wireType: testData.wireDescription.wireType === 'rectangular' ? WireType.RECTANGULAR : WireType.ROUND,
            outerDiameter: testData.wireDescription.outerDiameter,
            outerWidth: testData.wireDescription.outerWidth,
            outerHeight: testData.wireDescription.outerHeight
          });
          const bobbinDesc = new BobbinProcessedDescription(testData.bobbinDescription);
          
          window.currentShape = builder.getTurn(turnDesc, wireDesc, bobbinDesc, testData.isToroidal);
        }
        
        // Get mesh for visualization
        const meshData = window.currentShape.mesh({ tolerance: 0.0001, angularTolerance: 0.1 });
        addMeshToScene(meshData);
        
        log('âœ“ Geometry generated successfully!', 'success');
        document.getElementById('exportStlBtn').disabled = false;
        document.getElementById('exportStepBtn').disabled = false;
        
      } catch (error) {
        log('âœ— Error generating geometry: ' + error.message, 'error');
        console.error(error);
      }
    };
    
    // Export functions
    window.exportSTL = function() {
      if (!window.currentShape) return;
      
      try {
        const stlData = window.currentShape.exportSTL();
        downloadBlob(stlData, 'magnetic_part.stl', 'model/stl');
        log('âœ“ STL exported successfully!', 'success');
      } catch (error) {
        log('âœ— STL export failed: ' + error.message, 'error');
      }
    };
    
    window.exportSTEP = function() {
      if (!window.currentShape) return;
      
      try {
        const stepData = window.currentShape.exportSTEP();
        downloadBlob(new Blob([stepData]), 'magnetic_part.step', 'application/step');
        log('âœ“ STEP exported successfully!', 'success');
      } catch (error) {
        log('âœ— STEP export failed: ' + error.message, 'error');
      }
    };
    
    function downloadBlob(data, filename, mimeType) {
      const blob = data instanceof Blob ? data : new Blob([data], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function log(message, type = 'info') {
      const status = document.getElementById('status');
      status.className = type;
      status.textContent = message;
    }
    
    // Start initialization
    init();
  </script>
</body>
</html>
